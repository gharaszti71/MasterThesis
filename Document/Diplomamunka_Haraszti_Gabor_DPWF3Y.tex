\documentclass[a4paper,oneside,12pt]{report}

%Magyar nyelvi támogatás (Babel 3.7 vagy késõbbi kell!)
\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}

%Az ékezetes betûk használatához:
\usepackage{t1enc}% ékezetes szavak automatikus elválasztásához
\usepackage[latin2]{inputenc}% ékezetes szavak beviteléhez latin2

% A formai kovetelmenyekben megkövetelt Times betûtípus hasznalata:
\usepackage{times}

%Az AMS csomagjai
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

%A fejléc láblécek kialakításához:
\usepackage{fancyhdr}

%Természetesen további csomagok is használhatók,
%például ábrák beillesztéséhez a graphix és a psfrag,
%ha nincs rájuk szükség természetesen kihagyhatók.
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{epsfig}

% X11 színek
\usepackage{xcolor}

%Tételszerû környezetek definiálhatók, ezek most fejezetenkent egyutt szamozodnak, pl.
\newtheorem{tét}{Tétel}[chapter]
\newtheorem{defi}[tét]{Definíció}
\newtheorem{lemma}[tét]{Lemma}
\newtheorem{áll}[tét]{Állítás}
\newtheorem{köv}[tét]{Következmény}

%Ha a megjegyzések és a példak szövegét nem akarjuk dõlten szedni, akkor
%az alábbi parancs után kell õket definiální:
\theoremstyle{definition}
\newtheorem{megj}[tét]{Megjegyzés}
\newtheorem{pld}[tét]{Példa}

%Bekezdés elsõ sorának behúzása 0
\newlength\tindent
\setlength{\tindent}{\parindent}
\setlength{\parindent}{0pt}
\renewcommand{\indent}{\hspace*{\tindent}}

%Margók:
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 231mm
\footskip 20mm

% sorköz 1,15
\linespread{1.15}

\begin{document}
	
	%A FEJEZETEK KEZDÕOLDALAINAK FEJ ES LÁBLÉCE:
	%a plain oldalstílust kell átdefiniálni, hogy ott ne legyen fejléc:
	\fancypagestyle{plain}{%
		%ez mindent töröl:
		\fancyhf{}
		% a láblécbe jobboldalra kerüljön az oldalszám:
		\fancyfoot[C]{\thepage}
		%elválasztó vonal sem kell:
		\renewcommand{\headrulewidth}{0pt}
	}
	
	%A TÖBBI OLDAL FEJ ÉS LÁBLÉCE:
	\pagestyle{plain}
	\fancyhf{}
	\fancyhead[L]{}
	\fancyfoot[C]{\thepage}
	
	%A címoldalra se fej- se lábléc nem kell:
	\thispagestyle{empty}
	
	
	\begin{center}
		\vspace{0.5cm}
		
		{\textmd \bf NEUMANN J\'{A}NOS
			INFORMATIKAI KAR
		}
		
		\vspace*{3.8cm}
		
		{\LARGE\bf DIPLOMAMUNKA}
	
		\vspace*{10cm}
		
		\vspace*{1cm}
		
		%Értelemszerûen megváltoztatandó:
		\begin{tabular}{ r r }
			%\hline
			% after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
			OE-NIK & HARASZTI GÁBOR \\
			0 & 0 \\
			% \hline
		\end{tabular}
		\begin{flushleft}
			{\Large\bf OE-NIK            HARASZTI GÁBOR}
		\end{flushleft}
		\vspace*{2.3cm}
		
		{\Large
			Budapest
			\\
			\vspace{2mm}
			2019
		}
	\end{center}
	
	
	%A tartalomjegyzék:
	\tableofcontents
	
	
	\chapter{Bevezetés}
	
	A felhõ technológia mára már a mindennapok részévé vált az információ technológiát felhasználó cégeknél. Számos elõnyt jelent a felhasználók számára, de leginkább olcsón üzemeltethetõ és rugalmasan méretezhetõ infrastruktúrát ad a megfelelõ biztonsággal. Mindezt bérleti konstrukcióban szolgáltatja a beruházási konstrukcióval szemben, mely költséghatékonyabb a cégek számára.\\
	
	Több területen is fel tudják a cégek használni, az intranetes rendszereiktõl kezdve az internetes megjelenést biztosító rendszereken át a partnerek felé nyitott extranetes megoldásokig. A felhõ technológiák fontosságát jól jelzik, hogy nélkülük nem létezhetnének azok a mára már természetesnek vett szolgáltatások az Interneten, amiket százmilliók, milliárdok vesznek igénybe nap mint nap, nélkülük nem lehetne kiszolgálni a 3 milliárd Internet felhasználót.\\
	
	Manapság már az Interneten megjelenõ új adatok több, mint 80\%-a nem emberi kéz által létrehozott adat, a felhasznált rendszerek generálják azokat, beleértve az ipari rendszerek által létrehozott adatmennyiséget, az egyre terjedõ IoT alkalmazásokon át az egyéb kiberfizikai rendszerek által kibocsátott adatokig. Fontos tényezõ lett a hatalmas adatvagyon -- big data -- elemzése, ami nem létezhetne a felhõk számítási és adattárolási kapacitása nélkül. Manapság már a gyárak, ipari üzemek sem nélkülözhetik a felhõ technológiák használatát, a robotrendszereken és szenzorokon keletkezett adatok alapján jobb rugalmassággal tudják az adatokat feldolgozni és vezérelni a gyártás folyamatot.\\
	
	Fontos felhasználási területe lesz a felhõ szolgáltatásoknak a szolgáltató robotok. Jelenleg ugyan elenyészõ a számarányuk az ipari robotokhoz képest, viszont a jövõben ez jelentõsen változni fog -- egyes becslések szerint a 2015-ös 22\%-ról 2025-re 66\%-ot várnak --. Az ISO 13482-es szabvány szerint az ipari és szolgáltató robotoknak a definíciója:\\
	
	\begin{description}
		\item[ipari robot:] Az ipari robot egy automatikus irányítású, újraprogramozható, többcélú automatikus ipari feladatok elvégzésére használt manipulátor, három vagy több tengelye programozható, melyek lehetnek rögzítettek vagy mobilak.\vspace{-9pt}
		\item[szolgáltató robot:] Olyan robot, amely hasznos feladatokat hajt végre emberek vagy berendezések számára, kivéve az ipari automatizáló berendezéseket.\vspace{-9pt}
	\end{description}

	\bigskip

	Mint látható a megfogalmazásból a szolgáltató robotok definíciója elég tág, ezért érdemes pár egyéb szempont szerint is megvizsgálni, ami a Robotmechanizmusok tankönyv \cite{RobotCsop} szerint a következõ:\\
	
	\begin{tabular}{ | p{4cm} | p{5cm} | p{5cm} | }
		\hline
		& IPARI ROBOTOK & SZOLGÁLTATÓ ROBOTOK \\
		\hline
		\hline
		MUNKAKÖRNYEZET &  Ellenõrzött és jól meghatározott környezet & Rendezetlenebb, nehezebben definiálható környezet \\
		\hline
		FELHASZNÁLÓK & Betanítás speciális feladatokra & A betanítás a tevékenységek széleskörû skáláját öleli fel \\
		\hline
		BIZTONSÁG & Gépfüggõ & Robot és felhasználófüggõ \\
		\hline
		MUNKAFILOZÓFIA & Robotok és emberek elkülönítése & Robotoknak és embereknek meg kell osztozniuk a munka-területen, hogy szolgáltatást nyújtsanak/kapjanak \\
		\hline
		GÉP TERVEZÉSE & Megbízásra rugalmasan reagál & Igényre rugalmasan reagál \\
		\hline
	\end{tabular}

	\bigskip
	\bigskip
	
	A diplomamunka feladat fõ célja, hogy az ipari robotika igényei mentén feltárja a felhõ technológiákat felhasználó különbözõ szoftver architektúra irányokat és egy kísérleti PoC\footnote{Proof of Concept} környezetet kiépítése a megoldások mérnöki és tudományos vizsgálatához. A megvalósításnál törekedni kell az elterjedt nyílt forráskódú technológiák használatára.\\
	
	A feladatnak meg kell valósítania különbözõ környezetekben egy példa alkalmazást, egy pályatervezési feladatot. A felépítendõ rendszer része lesz egy robot a maga környezetével, helyi szerver számítógép, valamint több felhõ rendszer is, úgy mint a Microsoft Azure és Amazon AWS rendszere. Külön említést érdemel a Rapyuta\cite{Rapyuta} specifikus robot felhõ szolgáltatásának vizsgálata is.\\
	
	\chapter{Irodalmi áttekintés}
	
	A munka megkezdése elõtt célszerû tájékozódni a probléma lehetséges megoldásairól a hazai és nemzetközi szakirodalomban, ami után a megoldási alternatívák már ki tudnak rajzolódni és lehetséges lesz szakmailag megalapozott javaslat megfogalmazására.\\

	Galambos Péter cikkébõl \cite{GP_Cloud} megtudhatjuk, hogy habár sokáig megfelelt a robotikában a helyi kontrollerekrõl vezérelni a robotokat, a manapság szükséges számítási kapacitás igénynek ez már nem felel meg. Az új kihívások szükségessé teszik külsõ erõforrások bevonását is a munkába. A kapacitás bõvítésnek több módja is van a lokális szerverektõl a publikus felhõ szolgáltatásokig bezárólag. A cikk bemutatja a hagyományos IT területtõl némileg eltérõ robotikai alkalmazások szükségleteit a felhõ szolgáltatásokban.\\
	
	Elõször ismertetésre kerülnek a fõbb paradigmák a robotika kontextusában:\\
	
	\textbf{Cloud computing:} azaz felhõ számítástechnika, hozzáférés nagy, jól skálázható hálózati számítási kapacitásokhoz (végrahajtási, memória és disk) távolról. Ez az infrastruktúra lehet privát, publikus és hibrid.\\
	
	\textbf{Edge computing:} A robot kontrollerek mellett, helyi erõforrásként felhasznált számító-gépeket használhatunk azon feladatok elvégzésére, melyeket nem praktikus a felhõbe tenni -- például a nagy és folyamatosan generált adatmennyiség miatt, amire jó példa a nagy tömegû, robot szenzorokból érkezõ adatok elõ-feldolgozása -- valamint képesek gateway-ként illeszteni a helyi rendszereket az Internet követelményeinek megfelelõen a felhõhöz. Ide tartoznak még a beépített eszközök számítási kapacitásai, melyek elõfeldolgozást végeznek a magasabb absztrakciós szintek számára.\\
	
	A cikk továbbá kitér a felhõbe kiszervezett számítástechnika elõnyeire és hátrányaira, az elfogadható késleltetés és adatforgalom tükrében. Minden esetben a tervezõ mérnök kezébe adva a döntés jogát az egyes szolgáltatások helyének megtervezésére az igények szerint. Bevezeti továbbá a \textbf{puppet robot}, azaz báb-robot fogalmát, mely, mely mint fizikai egység már csak az érzékelésért és beavatkozásért felelõs szemben a hagyományos gyártási forgatókönyvekkel.\\
	
	A folytatásban tisztázásra kerül egy nagyon fontos aspektusa a témának, az architekturális kihívások és kulcs technológiák a felhõ robotikában. a szerzõ élesen elkülönít kétféle szolgáltatás típust -- vagy inkább képességet, robotikai értelemben az SaaS inkább Skills as a Service-t jelent -- az állapot-információk szerint, mégpedig:\\
	
	\textbf{Context-free:} azaz állapot független szolgáltatásoknak nincs szükségük több információra, mint például a pillanatnyi állapot, vagy az alkalmazás belsõ állapota. Mûködésükhöz elegendõ a meghívásukhoz szükséges adat. Ezek a szolgáltatások tipikusan egyszerûen implementálhatóak, akár RESTful microservice-ben, akár felhõs funkcióban  -- mint amilyen az AWS Lambda, vagy az Azure Functions -- és könnyen skálázhatóak maradnak.\\

	\textbf{Contextful:} azaz állapot függõ szolgáltatásoknak szükségük van információra a tárgyrendszerrõl, annak fizikai struktúrájáról, pillanatnyi belsõ állapotáról. Ezek a szolgáltatások viszont már nem skálázódnak jól, tipikusan szükséges hozzájuk dedikált ROS \cite{ROS} példány. (A ROS pillanatnyilag csak egy robot környezetet támogat, ezért kell környezetenként egy-egy ROS példányt futtatni)\\
	
	Xi Vincent Wang és munkatársai cikke \cite{ICMS} definiálja a mindenhol jelen lévõ gyártási rendszert a felhõ segítségével, illetve az ICMS rendszereket -- Interoperable Cloud Manufacturing System / Átjárható Felhõ Gyártási Rendszer --. A felhõ új üzleti modellt és lehetõségeket hoz a gyártásba, létrehozva a mindenhol jelen lévõ gyártást, segítve az SME-ket -- Small and Medium-sized Enterprises / Kis és közép vállalkozások -- a kezdeti nagy beruházási költségekkel járó robotikai beruházásokban, csökkentve a modern gyártási környezet kialakításához szükséges költségeket.\\
	
	A gyártási rendszerek új generációjának a létrehozása lehetõvé válik a felhõ szolgáltatások által, ami biztosítja a megfelelõ számítási kapacitást, képességeket és erõforrásokat. Más szemszögbõl nézve, a felhõben rendelkezésre áll az a kapacitás, amit költséges lenne egyenként fenntartani és kihasználatlan is lenne, ezért okos gondolat ezen erõforrásokat megosztani több gyártó rendszer között is, ideértve nem csak a számítási kapacitást, hanem azt a tudást is, ami egy-egy feladat hatékony megoldásához szükséges és valaki már elkészítette hozzá a szoftvert.\\
	
	A cikk foglalkozik a felhõ lehetõségeinek azokkal az aspektusaival is, amik megkönnyíthetik az ember-gép együttmûködést -- például kollaboratív robotok --. Minden ember másmilyen, mind fizikailag, mind mozdulatait tekintve. A felhõ számítási kapacitása így jobban képes alkalmazkodni az ember jelenléte miatt szükségessé vált változékony környezethez alkalmazkodni.\\
	
	Fontos részlet -- fõleg a gyártás számára --, hogy a robotrendszerek energia hatékony módon dolgozzanak, amiben szintén nélkülözhetetlen lehet a felhõ szerepe, de fontos lehet olyan helyzetekben is, amikor az energiavételezés lehetõségei korlátozottak. Az energia-optimalizált mûködés fontos szerepet játszik a zöld-felhasználásban, nem csak a gyártás területén.\\
	
	Adarsha Kharel és munkatársai cikke \cite{ROS_Cloud} a ROS alapú felhõ-robotikával foglalkozik. Elõször is fogalmakat tisztáz. Az operációs rendszer és a robotikai alkalmazások között definiál egy réteget, a "Robotic middleware"-t, mely az alkalmazások elõl elfedi a hardware és OS rétegeket, így egyszerûvé téve a robotikai fejlesztéseket és olcsóbbá téve azt. A ROS \cite{ROS} -- Robot Operating System -- egy nyílt forráskódú "meta-operációs rendszer", ami biztosítja a\\
	
	\begin{itemize}
		\item Hardware abstrakciót\vspace{-9pt}
		\item Alacsony szintû eszköz vezérlést\vspace{-9pt}
		\item Üzenet továbbítást\vspace{-9pt}
		\item Csomag menedzsmentet\vspace{-9pt}
	\end{itemize}

	\bigskip
	
	A cikk leírja a ROS alapfogalmait, részeit. Alapvetõ egység a Node, ami reprezentálja a ROS-on belül a felületet a programok felé. Egy ROS példány több Node-ot is indíthat. Az egyes Node-ok tartalmazzák azután a kétféle ROS szolgáltatás típust és a message-eket. 
	
	\begin{description}
		\item[message] A message-ek az üzeneteket reprezentálják ROS-on belül.\vspace{-9pt}
		\item[service] A service-ek message párokat jelképeznek, kérés/válasz-ként, más rendszerekbe a függvények felelnek meg nekik.\vspace{-9pt}
		\item[topic] A Node-ok fel tudnak iratkozni topic-okra és maguk is tudnak kiajánlani topic-okat -- megvalósítva az informatikában jól ismert publisher/subscriber mintát --. Egy topic-ba több node is írhat (publish) és több node is olvashat (subscrbe) belõle. \vspace{-9pt}
	\end{description}

	\bigskip
	
	A ROS-t számos nyelvbõl el lehet érni, , többek között C++, Python, lisp, Java, stb. környezetekbõl. Illetve rendelkezik egy csomag kezelõvel, amivel finomhangolható, hogy mely szoftverkomponensek legyenek felhasználva az adott ROS példányban. A ROS elsõdleges célja, hogy támogassa a kód újrafelhasználást a robotikai kutatásokban és fejlesztésekben \cite{ROS}. A ROS támogatja a moduláris, "tool-based" fejlesztés filozófiáját a robo-tikában.\\
	
	Pablo González-Nalda és munkatársai ROS és Docker alapú kiber-fizikai -- CPS, Cyber-Physical Systems -- architektúra tervezéssel foglalkozó cikke \cite{CPS} bevezetést nyújt általánosságban az ICT -- Information and Communication Technologies -- rendszerek tervezési aspektusaiba, legfõképpen az ipari és CPS felhasználások tekintetében, érintve a tervezõ rendszerektõl az Ipar 4.0-n át az IoT rendszerekig. Kitér a FOSS -- Free and Open-Source Systems -- rendszerek felhasználhatóságára, a ROS hasznára, mint a kód újrafelhasználhatóság és magas szintû integráció lehetõségére. \\
	
	A cikk foglalkozik a könnyûsúlyú -- lightweight -- virtualizációval, ezen belül is a Docker konténer technológiájával. Ez a szoftver nem kívánja meg, hogy minden egyes ROS példányhoz külön operációs rendszert is installálni kelljen, hanem egyugyanazon operációs rendszeren képes futtatni több ROS példányt is, ezzel erõforrásokat megtakarítva az adott gép hardware-én.\\
	
	Végül a cikk áttekinti a CPS rendszerek tervezésének hardware aspektusait, kezdve az egyszerû Raspberry Pi-tõl az ipari PLC-n át -- Programmable Logic Controller -- a PC-kig. Operációs rendszernek -- a PLC kivételével -- Linux-ot ajánl, valamint a ROS-t, mint middleware-t.\\
	
	Christopher Crick és munkatársai Rosbridge-el fogglalkozó cikke \cite{Rosbridge} bemutatja a Rosbridge-et, mint a ROS egy köztes réteg absztrakciós szintjét, interfészt a nem ROS felhasználók felé. Lényegében a Rosbridge létrehoz a ROS szolgáltatásaihoz egy roxy-t, amit más környezetekbõl fel tudunk használni, ráadásul akár az internetrõl is, mert a tûzfalbarát WebSocket-et használja a kliensek felé.\\
	
	A cikk bemutatja a ROS-t is. Legfelül vannak az egymással üzeneteket váltó Node-ok, amik szervizekkel és topic-okkal kommunikálnak egymással. A szervizeket úgy kell elképzelni, mint távoli funkció hívásokat, míg a topic-ok olyan folyamatos adatfolyamok, melyekbe "bárki" beleírhat és melyek üzeneteire "bárki" feliratkozhat.\\
	
	A Rosbridge egy következõ absztrakciós szint a ROS-hoz képest. Képes igény szerint elindítani és leállítani ROS node-okat, a kommunikációt a kliensekkel pedig JSON formában bonyolítja. Lényegében bármely klienssel képes kommunikálni, amelyik "megérti" a JSON formátumot, Web alkalmazásokkal, vagy például Java, .NET szoftverekkel is. Nem csak HTML5 WebSocket-ekkel képes kommunikálni a klienseivel, hanem akár hagyományos POSIX IP socketekkel is. Kiadtak hozzá egy Javascript könyvtárat is a ROSJS-t, amit könnyen integrálni tudunk a Javascript-ben megírt programokhoz.\\
	
	Ben Hu és munkatársai Cloudroid-al foglalkozó cikke \cite{Cloudroid} betekintést enged egy nyílt forráskódú felhõ keret-rendszerbe \cite{CloudroidWeb}, mely lehetõséget biztosít a meglévõ robotikai szoftverek számára, hogy felhõbe konvertálhatók legyenek, biztosítva számukra a teljes átalakítási transzparenciát az Internet-en elért felhõ szolgáltatás felhasználása mellett, a megfelelõ QoS -- Quality of Service -- biztosításával. A biztonságot növelõ megoldása, hogy ha hálózati hiba keletkezik képes a kliensnek legenerált Stub visszakapcsolni lokális hívásra, hogy ne akadjon meg végzetesen az elkezdett folyamat.\\
	
	A Cloudroid mögöttes technológiája a Rosbridge, annak absztrakciójára épül, hasonlóan, mint a Rapyuta publikus robotikai felhõ szolgáltató rendszere, mindketten megvalósítják a PaaS -- Platform as a Service -- infrastruktúra szolgáltatást. Bevezet négy mehanizmust:
	 
	\begin{description}
		\item[Öntartalmazó VM csomag:] Amikor egy ROS csomagot migrálunk a felhõbe, akkor az nem lenne képes kommunikálni a ROS Master-el, így ilyenkor automatikusan becsomagolódik egy Docker konténerbe, ami tartalmazni fogja a mûködéshez szükséges összes többi ROS csomagot.\vspace{-9pt}
		
		\item[Felhõ bridging:] Az adoptált Rosbridge A ROS protokolját konvertálja JSON formátumúvá és WebSocket alapú protokollá..\vspace{-9pt}
		
		\item[Igény szerinti szolga példányosítás és szétosztás:] A Cloudroidban a szervizbõl két rész létezik: az interfész és a szolga, azaz egy Docker példány ami tartalmazza a ROS csomagot. Mivel a ROS egy robot kiszolgálására készült, ezért a Cloudroid minden kliens számára más-más Docker példányt készít.\vspace{-9pt}
		
		\item[Szolgáltatás Stub automatikus generálása:] A Cloudroid-on futó szolgáltatások elérhetõek bármely manuálisan megírt WebSocket kliensssel. Ezen túl a Cloudroid képes automatikusan legenerálni a szolgáltatás eléréséhez egy stub-ot, amivel kényelmesen elérhetõ lesz a szolgáltatás a kliensekrõl.\vspace{-9pt}
		
	\end{description}
	
	.\vspace{9pt}
	
	Russell Toris és munkatársai Robot Web Tools-al foglalkozó cikke \cite{RWT} a nevezett, Rosbridge-re épülõ Javascript keretrendszerrel foglalkozik. A ROSJS mellett ez a másik feltörekvõ, bár kicsit más készletet tartalmazó, Rosbridge-re épülõ keretrendszer. Alapvetõen három részbõl tevõdik össze az RWT, a {\em roslibjs} egy kliens könyvtár, a {\em ros2djs} és a {\em ros3djs} pedig vizualizációs könyvtár. \\
	
	A {\em roslibjs} felhasználható bármely helyen mindenféle vizualizációs függõség nélkül. Egy kliens könyvtár, ami képes kommunikálni a ROS topic-okkal és szervizekkel. Tartalmaz továbbá eszközöket az alapvetõ robotikai feladatok ellátására, például transzfomációk, URDF -- Unified Robot Description Format -- parser és alapvetõ mátrix, vektor számítások.\\
	
	A {\em ros2djs} és a {\em ros3djs} vizualizációs könyvtárak a ROS-al összefüggõ adatokhoz -- az EaselJS és three.js továbbfejlesztései --, például robot modellek, vagy térképek, lézer letapogatások és pontfelhõk számára. Mindkét könyvtár HTML5 {\tt <canvas>} elemre rajzol.\\
	
	Az RWT-ben külön figyelmet fordítottak a streaming adatok megfelelõ kezelésére, például pontfelhõk folyamatos megjelenítésére. Az RWT vizualizációs része használja a HTML5 {\tt <video>} és {\tt <img>} elemeit a megjelenítésükhöz VP8 codec felhasználásával.\\
	
	Carla Mouradian és munkatársai cikke \cite{Disaster} egy nagyszabású, katasztrófa keresési és mentési feladatokat ellátó nagyon összetett rendszer tervezésérõl szól, amit már csak a felhasznált felhõs és egyéb technológiák száma is bizonyít. Az IoT-tõl -- Internet of Things -- kezdõdõen, az RFID-n át -- Radio-Frequency Identification --, a különbözõ felhõ technológiákig, SaaS, PaaS, IaaS. Az esettanulmány a már említett technológiák -- úgy mint, ROS, virtualization, Rapyuta -- felhasználásával épít ki egy komplex, katasztrófa környezetben használható, felhõ alapú rendszert.\\
	
	\chapter{Felhasznált technológiák bemutatása}
	
	A diplomamunka feladat által megvalósítandó PoC környezet kiépítéséhez több technológiát is meg kellett vizsgálni, mint lehetséges alternatívákat és a munkához megfele-lõket ki kellett választani. A kialakítandó rendszerben használni kell majd saját szervereken futó virtualizációs környezeteket, leginkább konténer technológiával, futtatni kell HTTP szervereket, valamint ROS példányokat. A rendszer részei lesznek az Amazon AWS és Microsoft Azure felhõ szolgáltatók által nyújtott virtualizációs és funkcionális szolgáltatásai is. \\
	
	\section{Operációs rendszer}

	A részletes feladatkiírásnak megfelelõen elsõsorban a nyílt forrású operációs rendszereket vettem számításba. A kereskedelmi Windows változatok teljesen kizáródtak a választásból, mert rajtuk nem fut a ROS \cite{ROS}. Az open source operációs rendszerek közül a ROS által támogatottak tipikusan azok, melyek a Debian\cite{debian} platform csomagkezelõ szolgáltatásait használják. Pillanatnyilag a két támogatott -- Linux alapú, debian rendszerû -- operációs rendszer az Ubuntu Wily (15.10-es verzió), az Ubuntu Xenial (16.04-es verzió) és Debian Jessie (8-as verzió). Jelenleg ezek már mind elavult verziók, az Ubuntu LTS\footnote{LTS - Long Term Support (hosszútávú támogatás)} a 18.10-es verziónál tart, míg a Debian a 9.4.0 verziónál.\\
	
	A választás másik aspektusa, hogy az említett felhõ szolgáltatóknál mely Linux verziók támogatottak a háromból. A Microsoft Azure az Ubuntu Server 16.04 LTS verzióját, valamint a Debian 8 Jessie verziót is, azaz kettõt is a ROS platformjai közül. Az Amazon AWS szintén támogatja a Debian 8 Jessie verzióját, valamint az Ubuntu 16.04 LTS-t is.\\
	
	Az operációs rendszer kiválasztásánál a követelményeknek megfelel mind az Ubuntu 16.04 Xenial, mind a Debian 8 Jessie, így a döntést a Robot laborban meglévõ szokások és tudás dönti el. A kollégák, akik majd a PoC rendszeren fognak dolgozni és a késõbbiekben fel tudják építeni belõle a saját magukra hangolt rendszert, inkább az Ubuntu szoftveréhez értenek, így a választásom is erre esett, azaz \textbf{Ubuntu 16.04 LTS Server}\\
	
	\section{Virtualizációs technológia}
	
	A virtualizáció alatt általában azt értjük, ha egy fizikai számítógépen egyszerre több, egymástól független, izolált operációs rendszert tudunk futtatni, feléjük emulált virtuális számítógépet mutatva. Az izolációval el tudjuk érni, hogy az egyes operációs rendszerek ne tudjanak még végzetes hiba esetén se egymásra hatni, illetve a virtualizáció miatt a fizikai számítógép erõforrásait -- processzor, RAM, disk, egyéb IO -- is optimálisabban, a szükségleteknek megfelelõen tudjuk szétosztani az operációs rendszerek között.\\
	
	Manapság már a virtualizáció jelentése kibõvült a konténer technológiákkal is. Az alapötlet, hogy nincs szükség a teljes operációs rendszer virtualizációra a költséges memória és processzor többlet terheléssel, hanem elegendõ lenne a szoftvereket egymástól elkülöníteni azok eltérõ környezetével együtt, a közösen használt operációs rendszer elegendõ védelmet nyújt a processzek\footnote{Egymástól elkülönített folyamatok védett memóriával} elválasztásához, elegendõ lenne az operációs rendszer kernelében\footnote{Az operációs rendszer magja, mely a processzeket futtatja} elkülöníteni a folyamatot.\\
	
	\begin{figure}[ht!]
		\begin{center}
			\includegraphics[width=12cm]{container-vs-vm.eps}
			\caption{VM és Konténer különbsége}
			\label{fig:vmvscontainer}
		\end{center}
	\end{figure}

	A ~\ref{fig:vmvscontainer} ábrán a \pageref{fig:vmvscontainer}. oldalon erre látunk példát. A fizikai gép a gazda\footnote{Host Operating System} operációs rendszert futtatja, ami fölött fut egy virtualizációs\footnote{Hypervisor} réteg, ami futtatja az egyes vendég\footnote{Guest Operating System} operációs rendszereket. Ezeken a vendég operációs rendszereken futnak a nekünk szükséges alkalmazások a nekik szükséges környezettel -- például kódkönyvtárak, egyéb szükséges szoftverek --.\\
	
	A másik példa a konténer technológiát mutatja be, jelen esetben a Dockerrel. Itt a fizikai gépen az az operációs rendszer fut, amin a virtualizált alkalmazásokat akarjuk futtatni. A Docker engine, beépülve az operációs rendszer kernelébe jelenti a következõ réteget, mely már képes a konténereket futtatására, azaz a konténerizált processzek és környezetük izolációjára.\\
	
	Jól látszanak az elõnyök, megspóroltuk az izolált disk területnek a vendég operációs rendszerekhez szükséges mennyiségét, megspóroltuk a RAM-nak a vendég operációs rendszerek futtatásához szükséges többlet memória területét, megspóroltuk a vendég operációs rendszerek processz kezeléséhez szükséges többlet processzor kapacitását. Viszont nem menjünk el a nyilvánvaló hátrányok mögött se. A konténer technológia nem képes többféle operációs rendszer futtatására, se többféle frissítési szintû, verziójú, de azonos operációs rendszer kezelésére se.\\
	
	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[width=11cm]{docker-architektura.eps}
		\caption{Docker kapcsolata a Linux kernellel}
		\label{fig:dockervskernel}
	\end{center}
	\end{figure}
	
	A Docker elõdje a 2008-ban megjelent LXC~\footnote{Linux containers} volt, amely ugyan konténer alapú, de teljes virtuális gépeket kezel. Ezzel szemben a Docker a konténer formátum egységesítése mellett komoly erõfeszítéseket tett az egyetlen program kedvéért létezõ konténerek mûködésé-ért.\\ 
	
	Architektúráját a ~\ref{fig:dockervskernel} ábra a \pageref{fig:vmvscontainer}. oldalon szemlélteti. Bemutatja, hogy a Docker milyen kapcsolatban áll a Linux kernellel. Látható, hogy a namespace-k és az erõforrások kiosztásáért, limitációjáért felelõs cgroups is a kernel részegysége. A libcontainer a jelenlegi, az LXC driver-t váltó megoldás, gyakorlatilag nem más, mint egy egységes interfész konténerek létrehozására. A libvirt egy API, egy menedzsment eszköz a virtualizációhoz. A systemd-nspawn egy chroot-hoz hasonló megoldás, azonban ez utóbbi teljesen virtualizálja a fájlrendszer hierarchiáját, a folyamatokat, illetve az IPC alrendszereket.\cite{DockerArchi}\\
	
	A PoC-hoz szükséges lesz virtualizációs technológia használatára, ahol az elõzõ pontban megvizsgált operációs rendszereken virtualizálva tudjuk majd futtatni a ROS példányokat. Alapvetõen kétféle virtualizáció lehetséges. Vagy minden egyes ROS példánynak allokálunk egy gazda-gépen futó, komplett vendég operációs rendszert, ami megfelel a hagyományos virtualizációs technológiának, vagy pedig valami konténer technológiát használunk. A ROS követelményeit áttekintve a feladat nem igényel feltétlenül nehézsúlyú megoldást, nincs szükség sokféle operációs rendszerre és a megvizsgált felhõ technológiák is támogatják, ezért a Docker konténer technológiáját választottam.\\
	
	\section{Felhõ szolgáltatások}
	
	A feladat részét képezi több felhõ technológia kipróbálása, rendszerbe integrálása. Alapvetõen két univerzális felhõ szolgáltatót fogok kiértékelni. Az egyik az Amazon AWS-e a másik a Microsoft Azure szolgáltatása. Ezen kívül kiértékelésre kerül még egy robotikára specializált, ROS alapú felhõ szolgáltató is, a Rapyuta\cite{Rapyuta}.\\
	
	%https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html
	Az Amazon Docker alapú felhõ szolgáltatása az Amazon ECS\footnote{Elastic Container Service}, ami támogatja a kiválasztott Ubuntu 16.04 verziójú Linux operációs rendszert és a ROS-t is. A Docker image elkészítése után az feltölthetõ az Amazon ECR\footnote{Elastic Container Registry}-be, majd elindítható akár több példányban is.\\
	
	%https://azure.microsoft.com/en-us/services/kubernetes-service/docker/
	A Microsoft Azure szolgáltatása a Docker Enterprise Edition-t használ. Az Amazon-hoz képes sokkal több platformot támogat, beleértve a számunkra szükséges Ubuntu 16.04-es verziót is.\\
	
	% Kubernetes - Egy mikroservice és Docker mgmt cucc: https://kubernetes.io/
	
	\chapter{A megvalósítandó rendszer specifikációja}
	
	A megvalósítandó rendszer egy PoC, ami nem feltétlenül egy feladatra optimalizált konkrét megvalósítás, sokkal inkább a technológiák kipróbálására szolgáló megoldás, így minden kipróbálandó technológia része lesz a kialakított architektúrának. Alapvetõen célja, hogy a robotikai kutatások, alkalmazások számára ki lehessen választani a legjobb megoldást a rendelkezésre álló eszközkészletbõl. A rendszer által megvalósított példa feladat a pályatervezés lesz, amit a rendszerben különféle pontokra kihelyezve tesztelünk sebességre és válaszidõre.\\
	
	%https://github.com/cyberdb/Cloudroid
	A rendszerhez felhasználjuk a Cloudroid\cite{Cloudroid} szoftvert a ROS szolgáltatásainak kiajánlására az Internet alapú hálózat felé. 
	
	
	
	\begin{thebibliography}{99}
		% 10-nél több hivatkozás esetén
		
		\addcontentsline{toc}{chapter}{Irodalomjegyzék}
		
		\bibitem{GP_Cloud}Péter Galambos: Cloud-, Fog-, and Mist Computing in Service of Advanced Robot Applications, {\em {\color{red} ide be kell irni majd, hogy GP cikke hol jelent meg!}}, 1969, pp.111-222.\vspace{-9pt}
		
		\bibitem{ICMS}Xi Vincent Wang, Lihui Wang, Abdullah Mohammed, Mohammad Givehci (Department of Production Engineering, KTH Royal Institute of Technology, Stockholm, Sweden): Ubiquitous manufacturing system based on Cloud: Robotics, {em ELSEVIER, Robotics and Computer-Integrated Manufacturing}, 45.szám, 2017, pp.116-125\vspace{-9pt}
		
		\bibitem{ROS} Robot Operating System (http://www.ros.org/about-ros/), utoljára megtekintve: 2018.11.02.\vspace{-9pt}
		
		\bibitem{ROS_Cloud}Adarsha Kharel, Dorjee Bhutia, Sunita Rai, Dhruba Ningombam: Cloud Robotics using ROS, {\em International Journal of Computer Applications \textregistered} ~(IJCA) (0975 ? 8887),	{\em National Conference cum Workshop on Bioinformatics and Computational Biology}, NCWBCB- 2014, pp.18-21.\vspace{-9pt}
		
		\bibitem{CPS}Pablo González-Nalda, Ismael Etxeberria-Agiriano, Isidro Calvo: A modular CPS architecture design based on ROS and Docker, {em \copyright Springer-Verlag France}, 2016, pp.950-955.\vspace{-9pt}
			
		\bibitem{Rosbridge}Christopher Crick, Graylin Jay, Sarah Osentoski, Benjamin Pitzer, Odest Chadwicke Jenkins: Rosbridge: ROS for Non-ROS Users {\em \textcopyright Springer International Publishing Switzerland}, 2017, pp.493-503\vspace{-9pt}
			
		\bibitem{Docker}Docker lightweight container engine (https://www.docker.com/products/docker-engine), utoljára megtekintve: 2018.11.02.\vspace{-9pt}
		
		\bibitem{Cloudroid}Ben Hu, Huaimin Wang, Pengfei Zhang, Bo Ding, Huimin Che: Cloudroid: A Cloud Framework for Transparent and QoS-aware Robotic Computation Outsourcing, {\em IEEE 10th International Conference on Cloud Computing} 25-30 June 2017, pp.114--121 \vspace{-9pt}

		\bibitem{RWT}Russell Toris, Julius Kammerl, David V. Lu, Jihoon Lee, Odest Chadwicke Jenkins, SarahOsentoski, Mitchell Wills, Sonia Chernova: Robot Web Tools: Efficient Messaging for Cloud Robotics, {\em 2015 IEEE/RSJ International Conference on Intelligent Robots and Systems} 2015-09, pp.4530--4537 \vspace{-9pt}
		
		\bibitem{Disaster}Carla Mouradian, Sami Yangui, Roch H. Glitho: Robots as-a-Service in Cloud Computing: Search and Rescue in Large-scale Disasters Case Study, {\em $15^{th}$ IEEE Consumer Communications and Networking Conference, Las Vegas, USA} 12-15 January 2018, pp.1--7 \vspace{-9pt}
		
		\bibitem{CloudroidWeb} Cloudriod cloud robotic platform Website (https://github.com/cyberdb/Cloudroid), utoljára megtekintve: 2018.11.02.\vspace{-9pt}
		
		\bibitem{RobotCsop} Dr. Szabó Zsolt, Budai Csaba, Dr. Kovács László, Dr. Lipovszki György: Robotmechanizmusok Web site tananyag, robotok csoportosítása fejezet (http://www.mogi.bme.hu/TAMOP/robotmechanizmusok/ch14.html), utoljára megtekintve: 2018.12.12.\vspace{-9pt}
		
		\bibitem{debian}Debian operációs rendszer (https://www.debian.org/), utoljára megtekintve: 2018.12.12.\vspace{-9pt}
		
		\bibitem{ubuntu}Ubuntu operációs rendszer (https://www.ubuntu.com/), utoljára megtekintve: 2018.12.12.\vspace{-9pt}
		
		\bibitem{Rapyuta}ROS-t és Cloudroid-ot felhasználó specifikus robot-felhõ szolgáltató (https://www.rapyuta-robotics.com/), utoljára megtekintve: 2018.12.12.\vspace{-9pt}
		
		\bibitem{DockerArchi} Ákos, Kovács: Docker, a konténer alapú virtualizáció {em Refaktor Magazin} 2018.12.13. (https://www.refaktor.hu/docker-a-kontener-alapu-virtualizacio-1-resz/), utoljára megtekintve: 2018.12.12.\vspace{-9pt}
		
	\end{thebibliography}
	
\end{document}